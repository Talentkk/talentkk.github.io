---
title: 2021.11.29 练习
date: 2021/11/29 
description: 　
---
## CF1609F

给出一个长度为 $n$ 的序列 $a$ ，求有多少个区间 $[l,r]$ 满足，区间中的最大值和最小值在二进制下 $1$ 的个数相同。

$1\leq n\leq 10^6,0\leq a_i\leq 10^{18}$

考虑枚举右端点，计算有多少合法的左端点。因为涉及到区间最大值和最小值，所以我们在右端点从左向右移动时，维护后缀 $\min$ 和 $\max$ 的单调栈。我们考虑在 $r\rightarrow r+1$ 的过程中，维护有多少合法的左端点。观察单调栈变化的过程（弹出若干元素，加入一个元素），发现如果我们能够快速查询在区间 $[L,R]$ 中有多少个 $i$ 满足区间 $[i,r]$ 的 $\min$ （或 $\max$）的 $1$ 的个数是 $v$ ，就可以快速维护合法左端点的个数。一种简单的想法是开 $2\times 60$ 棵线段树，前六十棵维护中的第 $x$ 棵维护： $[i,r]$ 的 $\min$ 的 $1$ 的个数等于 $x$ 的有哪些位置，后六十棵类似维护 $\max$ ，时间复杂度 $O(n\times \log(n))$ ，但空间会炸。

于是就考虑平衡一下，只开 $2\times 6$ 棵线段树，跑 $10$ 次维护这个过程。这样时间复杂度会乘 $10$ ，但可以通过。

## ARC130d

给一棵 $n$ 个节点的数，求有多少合法的排列长度为 $n$ 的排列 $P$，满足对于任意 $a,b,c$ ，如果 $a,b$ 相邻，$b,c$ 相邻，那么有 $P_a<P_b>P_c$ 或 $P_a>P_b<P_c$ 成立。对 $998244353$ 取模。

$1\leq n\leq 3000$

容易发现，对于一个节点 $u$ ，它要么比周围的节点都大，要么比周围的节点都小。我们把第一种情况的 $u$ 成为大点，第二种称为小点。

那么如果 $1$ 是大点还是小点确定了，所有点是大点还是小点也确定了（类似于黑白染色）。我们又观察到对于一个合法的排列 $P$ ，将 $P_i=n+1-P_i$ 后，对于任意一个点 $u$ ，它是大点就会变成小点，是小点就会变成大点。所以得出结论：**一个点是大点的方案和是小点的方案是一一对应的**。

考虑设 $dp(u,x)$ 表示对 $u$ 的这颗子树分配排列（$[1,siz_u]$），$u$ 分配到 $i$ 且 $u$ 是小点的方案数。现在假设我们已经得到了 $u$ 的所有儿子的 $dp$ 值 。根据上面的结论，如果我们设 $g(u,i)$ 为对 $u$ 的这颗子树分配排列，$u$ 分配到 $i$ 且 $u$ 是大点的方案数，则有$g(u,i)=f(u,siz(u)+1-i)$ ，接下来的过程中，我们是先假设 $u$ 是大点，计算 $g(u,i)$ ，再根据等式得到 $dp(u,i)$ 。

先假设 $u$ 只有两个儿子 $x$ 和 $y$ ，其中 $siz_x=n,siz_y=m$ ，则我们只关心 $x$ 和 $y$ 中 $P$ 值较大的那个。我们设 $f(i)$ 表示对 $x$ 和 $y$ 两棵子树进行分配，且 $\max(P_x,P_y)=i$ 的方案数。比如先假设 $P_x$ 更大，则我们枚举 $x$ 在 $x$ 的子树中是第 $i$ 大的，以及 $y$ 的子树中有 $j$ 个数比 $P_x$ 小，则有转移方程：
$$
f(i+j)\leftarrow dp(x,i)\times\sum_{k=1}^{j}dp(y,k) \times {i+j-1 \choose i-1}\times{n-i+m-j\choose n-i}
$$
预先将 $dp(y,i)$ 前缀和后，这一步的复杂度是 $siz_x\times siz_y$ 。

$P_y$ 更大时也是类似的。得到 $f$ 数组后，我们就容易求出 $g(u,i)$ （how?）。考虑有更多儿子时，其实和两个儿子是类似的，我们先将 $u$ 的前两个儿子的信息合并，再将第三个儿子与前面得到的信息合并，如此往复，就可得到类似的方法。

注意到每次将一个大小为 $x$ 和大小为 $y$ 的信息合并时的复杂度是 $x\times y$ 的，所以总复杂度是 $O(n^2)$ 的。

## TPC1670

有 $n$ 个数 $x_i$ ，其中 $x_1=0$ ，给出一个 $\frac{n\times(n-1)}{2}$ 个数的序列，表示这 $n$ 个数字之间两两的差的绝对值。求这 $n$ 个数字分别是多少，以不降的顺序输出。若有多种方案输出字典序最小的。

$2\leq n\leq 10,0\leq x_i\leq 10^6$ 

对于给出的序列，取出其中的最大值 $m$ ，那么 $m$ 就是 $x_i$ 中的最大值。再取出序列中的最大值 $t$ ，那么一定有一个点位于 $t$ 或 $m-t$ ，枚举这两种情况，并在序列中删去相应的数，递归进行。由于递归最深 $n$ 层，所以时间复杂度是指数级别的。序列可以用 `set` 维护。