---
title: 练习
date: 2021/10/15 
description: 　
---
## CF814D

有 $n$ 个圆，且两两只存在包含、相切或相离的关系。将其分为两组，每组中只有奇数次被覆盖的被算入面积，求面积和最大。

<!--more-->

$1\leq n\leq 10^3$

容易发现圆之间是树的关系，于是把每个圆看成一个点，$O(n^2)$ 建出一个森林。现在问题等价于给树上的每个节点染上黑白两种颜色，如果设第 $i$ 个点代表的圆的面积是 $s_i$ ，$i$ 到根的路径中**与 $i$ 颜色相同**的有 $c_i$ 个，则这样的答案是：

$\sum_{i}{s_i\times(-1)^{c_i}}$

现在要最大化答案。容易归纳证明，对于每颗树，最优策略是只把第二层的点染黑，其余点染白。

## CF1598G

有一个只含字符1到9的字符串 $S$ 和一个不含0的数字 $X$ ，设 $num(l,r)$ 表示 $S$ 的字串 $S[l,r]$ 代表的数字，求任意一个三元组 $(a,b,c)$ 满足 $num(a,b)+num(b+1,c)=X$ 。

$1\leq |S|\leq 5\times 10^5,2\leq X\leq 10^{200000}$ 

不妨设 $num(a,b)=A,num(b+1,c)=B$ 且 $A$ 为较大者。设 $X$ 的长度为 $len$ ，则 $A$ 的长度只有可能是 $len$ 或 $len-1$ 。当 $|A|=len$ 时，$|B|=len-\operatorname{lcp}(A,X)-1$ 或 $|B|=len-\operatorname{lcp(A,X)}$ 。当 $|A|=len-1$ 时， $|B|=len-1$ 。

使用 `Hash` 可以 $O(1)$ check。时间复杂度 $O(n)$ 。 

## BJ19351

有个人一开始在 $x$ 轴的位置，每单位时间他可以向左或向右走一步或者停在原地。有 $n$ 道闪电 $(t,x,r)$ ，表示 $t$ 时刻的时候这个人不能够站在 $(x-r,x+r)$ 这个区间内。有 $s$ 个询问 $(t,x)$，求出在 $t$ 时刻这个人能否走到位置 $x$ 。

$0\leq n,s\leq 200000,0\leq t\leq 10^9,-10^9\leq x\leq 10^9,1\leq r\leq 10^9$

如果设 $dp(i)$ 表示在时刻 $t$ ，$i$ 这个点能否到达（1能到达，0不能），则1将构成若干个连续段，且 $t$ 加 $1$ 时，每个连续段会向左右各扩张一个单位，而闪电就会把一个区间赋值成 $0$ 。我们可以用 `set` 维护每个连续段，并用 `priority_queue` 维护相邻两个连续段之间合并的时间。时间复杂度 $O(n\log(n))$  。

## CF867D

一个游戏有 $n$ 个卡关，按顺序在 $r$ 秒内完成算通关。对于第 $i$ 个卡关，有 $p_i$ 的概率用 $f_i$ 的时间完成，有 $1-p_i$ 的概率用 $s_i$ 的概率完成。每完成一个卡关后，可以决定继续下一个卡关或重新开始计时挑战。求期望完成时间。

$1\leq n\leq 50,1\leq s_i,t_i\leq 100,80\leq p_i\leq 90,\sum{f_i}\leq r\leq \sum{s_i}$

若设 $dp(i,j)$ 为到第 $i$ 关时（未完成 $i$ ），已花费 $j$ 秒的期望完成时间，则容易得到转移方程：
$$
dp(i,j)=\min(dp(1,0),p_i\times(dp(i+1,j+f_i)+f_i)+(1-p_i)\times(f(i+1,j+s_i)+s_i))
$$
这样的转移存在环，又因为有 $\min$ ，所以无法使用高斯消元。

考虑把 $dp(1,0)$ 的转移式展开，则等式右边一定是若干个关于 $dp(1,0)$ 的一次函数取 $\min$ 。作出左式和右式关于 $dp(1,0)$ 的函数图像（左式为一次函数，右式为上凸函数），因为只有一个交点，所以可以二分求出这个交点。具体地，通过二分左式的值，计算右式的取值，通过判断两个值的大小关系来决定往哪边移动。

## CF1606F

给出一棵 $n$ 个节点的有根树（根为 $1$），有 $q$ 组询问 $(u,i)$ 。在一组询问中，你可以删掉除了 $u$ 和 $1$ 以外的任意节点。当一个节点被删去后，它的儿子就变成了它父亲的儿子。假设进行了 $m$ 次操作后，$u$ 有 $c(u)$ 个儿子，问 $c(u)-m\times i$ 的最大值是多少。每组询问独立。

$1\leq n,q,i\leq 2\times 10^5$

考虑朴素的 $dp$ ，设 $dp(u,i)$ 表示以 $u$ 为根的这棵子树中，询问 $(u,i)$ 的答案。从儿子 $v$ 转移过来时，讨论 $v$ 是否要被删去，于是有转移方程：
$$
dp(u,i)=\sum_{v}{\max(dp(v,i)-i,1)}
$$
这样的 $dp$ 是 $O(n^2)$ 的，瓶颈在于状态数过多，以下先证明两个结论：

1. $dp(u,i)\leq dp(u,i+1)$ 

   假设 $dp(u,i+1)$ 的方案中删去了点集 $S$ ，那么在 $dp(u,i)$ 中也删去点集 $S$ 的价值一定小于等于 $dp(u,i+1)$ 。

2. 设 $d(u)$ 为节点 $u$ 的儿子数量，对于 $u\in [1,n]$ 只有 $O(n/(i+1))$ 个 $dp(u,i)\neq d(u)$ 。

   把转移方程 $\max$ 里面的1拿出来：
   $$
   dp(u,i)=d(u)+\sum_{v}{\max(dp(v,i)-i-1,0)}
   $$
   因为 $dp$ 是完全由 $d$ 决定的，即一个 $d$ 数组与一个 $dp$ 数组一一对应，所以我们考虑这样一种方式得到 $dp$ 数组的值。一开始 $d(x)=0,x\in[1,n]$ ，显然所有 $dp$ 也为0， 然后考虑把一个为 $0$ 的 $d(x)$ 变成它原来的值（$x$ 的儿子数量）会对 $dp$ 发生什么影响，发现最多会让 $x$ 的 $d(x)/(i+1)$ 个**原来 $dp(u,i) = d(u)$ 的祖先**变成 $dp(u,i)\neq d(u)$ 。所以把每个 $d$ 都变完后，对于一个固定的 $i$ ，最多会有 $\sum_{x}{d(x)/(i+1)}=(n-1)/(i+1)$ 个点满足 $dp(u,i)\neq d(u)$ 。

因为结论2，对于 $dp(u,i)\neq d(u)$ 的状态总个数是调和级数的。所以我们 $dp$ 的时候可以只存 $dp(u,i)\neq d(u)$ 的状态，又因为结论1，对于固定的 $u$ ，符合条件的状态一定是一个前缀，可以用 `vector` 维护。转移是 $O(1)$ 的，时间复杂度 $O(n\ln(n))$ 。