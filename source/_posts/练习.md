---
title: 练习
date: 2021/10/15 
description: 　
---
## CF814D

有 $n$ 个圆，且两两只存在包含、相切或相离的关系。将其分为两组，每组中只有奇数次被覆盖的被算入面积，求面积和最大。

$1\leq n\leq 10^3$

容易发现圆之间是树的关系，于是把每个圆看成一个点，$O(n^2)$ 建出一个森林。现在问题等价于给树上的每个节点染上黑白两种颜色，如果设第 $i$ 个点代表的圆的面积是 $s_i$ ，$i$ 到根的路径中**与 $i$ 颜色相同**的有 $c_i$ 个，则这样的答案是：

$\sum_{i}{s_i\times(-1)^{c_i}}$

现在要最大化答案。容易归纳证明，对于每颗树，最优策略是只把第二层的点染黑，其余点染白。

## CF1598G

有一个只含字符1到9的字符串 $S$ 和一个不含0的数字 $X$ ，设 $num(l,r)$ 表示 $S$ 的字串 $S[l,r]$ 代表的数字，求任意一个三元组 $(a,b,c)$ 满足 $num(a,b)+num(b+1,c)=X$ 。

$1\leq |S|\leq 5\times 10^5,2\leq X\leq 10^{200000}$ 

不妨设 $num(a,b)=A,num(b+1,c)=B$ 且 $A$ 为较大者。设 $X$ 的长度为 $len$ ，则 $A$ 的长度只有可能是 $len$ 或 $len-1$ 。当 $|A|=len$ 时，$|B|=len-\operatorname{lcp}(A,X)-1$ 或 $|B|=len-\operatorname{lcp(A,X)}$ 。当 $|A|=len-1$ 时， $|B|=len-1$ 。

使用 `Hash` 可以 $O(1)$ check。时间复杂度 $O(n)$ 。 

## BJ19351

有个人一开始在 $x$ 轴的位置，每单位时间他可以向左或向右走一步或者停在原地。有 $n$ 道闪电 $(t,x,r)$ ，表示 $t$ 时刻的时候这个人不能够站在 $(x-r,x+r)$ 这个区间内。有 $s$ 个询问 $(t,x)$，求出在 $t$ 时刻这个人能否走到位置 $x$ 。

$0\leq n,s\leq 200000,0\leq t\leq 10^9,-10^9\leq x\leq 10^9,1\leq r\leq 10^9$

如果设 $dp(i)$ 表示在时刻 $t$ ，$i$ 这个点能否到达（1能到达，0不能），则1将构成若干个连续段，且 $t$ 加 $1$ 时，每个连续段会向左右各扩张一个单位，而闪电就会把一个区间赋值成 $0$ 。我们可以用 `set` 维护每个连续段，并用 `priority_queue` 维护相邻两个连续段之间合并的时间。时间复杂度 $O(n\log(n))$  。

## CF867D

一个游戏有 $n$ 个卡关，按顺序在 $r$ 秒内完成算通关。对于第 $i$ 个卡关，有 $p_i$ 的概率用 $f_i$ 的时间完成，有 $1-p_i$ 的概率用 $s_i$ 的概率完成。每完成一个卡关后，可以决定继续下一个卡关或重新开始计时挑战。求期望完成时间。

$1\leq n\leq 50,1\leq s_i,t_i\leq 100,80\leq p_i\leq 90,\sum{f_i}\leq r\leq \sum{s_i}$

若设 $dp(i,j)$ 为到第 $i$ 关时（未完成 $i$ ），已花费 $j$ 秒的期望完成时间，则容易得到转移方程：
$$
dp(i,j)=\min(dp(1,0),p_i\times(dp(i+1,j+f_i)+f_i)+(1-p_i)\times(f(i+1,j+s_i)+s_i))
$$
这样的转移存在环，又因为有 $\min$ ，所以无法使用高斯消元。

考虑把 $dp(1,0)$ 的转移式展开，则等式右边一定是若干个关于 $dp(1,0)$ 的一次函数取 $\min$ 。作出左式和右式关于 $dp(1,0)$ 的函数图像（左式为一次函数，右式为上凸函数），因为只有一个交点，所以可以二分求出这个交点。具体地，通过二分左式的值，计算右式的取值，通过判断两个值的大小关系来决定往哪边移动。

## CF1606F

给出一棵 $n$ 个节点的有根树（根为 $1$），有 $q$ 组询问 $(u,i)$ 。在一组询问中，你可以删掉除了 $u$ 和 $1$ 以外的任意节点。当一个节点被删去后，它的儿子就变成了它父亲的儿子。假设进行了 $m$ 次操作后，$u$ 有 $c(u)$ 个儿子，问 $c(u)-m\times i$ 的最大值是多少。每组询问独立。

$1\leq n,q,i\leq 2\times 10^5$

考虑朴素的 $dp$ ，设 $dp(u,i)$ 表示以 $u$ 为根的这棵子树中，询问 $(u,i)$ 的答案。从儿子 $v$ 转移过来时，讨论 $v$ 是否要被删去，于是有转移方程：
$$
dp(u,i)=\sum_{v}{\max(dp(v,i)-i,1)}
$$
这样的 $dp$ 是 $O(n^2)$ 的，瓶颈在于状态数过多，以下先证明两个结论：

1. $dp(u,i)\leq dp(u,i+1)$ 

   假设 $dp(u,i+1)$ 的方案中删去了点集 $S$ ，那么在 $dp(u,i)$ 中也删去点集 $S$ 的价值一定小于等于 $dp(u,i+1)$ 。

2. 设 $d(u)$ 为节点 $u$ 的儿子数量，对于 $u\in [1,n]$ 只有 $O(n/(i+1))$ 个 $dp(u,i)\neq d(u)$ 。

   把转移方程 $\max$ 里面的1拿出来：
   $$
   dp(u,i)=d(u)+\sum_{v}{\max(dp(v,i)-i-1,0)}
   $$
   因为 $dp$ 是完全由 $d$ 决定的，即一个 $d$ 数组与一个 $dp$ 数组一一对应，所以我们考虑这样一种方式得到 $dp$ 数组的值。一开始 $d(x)=0,x\in[1,n]$ ，显然所有 $dp$ 也为0， 然后考虑把一个为 $0$ 的 $d(x)$ 变成它原来的值（$x$ 的儿子数量）会对 $dp$ 发生什么影响，发现最多会让 $x$ 的 $d(x)/(i+1)$ 个**原来 $dp(u,i) = d(u)$ 的祖先**变成 $dp(u,i)\neq d(u)$ 。所以把每个 $d$ 都变完后，对于一个固定的 $i$ ，最多会有 $\sum_{x}{d(x)/(i+1)}=(n-1)/(i+1)$ 个点满足 $dp(u,i)\neq d(u)$ 。

因为结论2，对于 $dp(u,i)\neq d(u)$ 的状态总个数是调和级数的。所以我们 $dp$ 的时候可以只存 $dp(u,i)\neq d(u)$ 的状态，又因为结论1，对于固定的 $u$ ，符合条件的状态一定是一个前缀，可以用 `vector` 维护。转移是 $O(1)$ 的，时间复杂度 $O(n\ln(n))$ 。

## CF1601D

有 $n$ 个人要爬一座初始高度为 $d$ 的山，每个人用二元组 $(p_i,a_i)$ 描述。对于一个人，若当前 $d\leq p$ ，他可以爬这座山，爬完后山的高度变为 $max(d,a)$ 。问最多有多少人可以爬山。

$1\leq n\leq 5\times 10^5,0\leq d\leq 10^9$

首先把 $p<d$ 的扔掉，然后将所有人分为两类，$p\geq a$ 和 $p<a$ 。考虑这样一种形成方案的方式，先从 $p<a$ 的人中选出一种合法方案，然后再将 $p\geq a$ 的人插入其中。这样显然是正确的。

那么对于 $p<a$ 的人的任意一种合法方案， $p\geq a$ 的人一定都可以被插入。

证明：假设 $p<a$ 的人求出的合法方案是 $x_1,x_2,...,x_k$ （即这些人依次爬山），那么一个 $p\geq a$ 的人 $y$，直接找到最大的 $i$ 满足 $a_{x_i}\leq p_y$ ，然后把 $y$ 插入到 $i$ 和 $i+1$ 之间就可以了。

所以现在问题就是如何对 $p<a$ 的人求最优的合法方案。容易发现，如果把一个人 $i$ 看作一个区间 $[p,a]$ ，这本质上就是在求最多的区间，使得区间两两不交。直接把所有区间按照右端点排序，然后贪心选择即可。

## CF1601E

给出 $n$ 个数 $a_i$ 和 $k$ ，有 $q$ 组询问，每组询问给出区间 $[l,r]$ ，求一个序列 $c_i$ 满足对于 $i\in[l,r]$ ， $\sum_{j=l}^{i}c_j\geq{\lfloor \frac{i-l}{k} \rfloor+1}$ ，序列 $c_i$ 的代价为 $\sum a_i\times c_i$ ，求代价最小。

$1\leq n,q\leq 300000,1\leq k\leq n$

容易发现这个代价本质上就是对一个后缀的若干段前缀 $\min$ 求和：
$$
\sum_{i=l+kx,x\in N}^{r}{\min_{j=l}^{i}{a_j}}
$$
如果我们设 $g_i=\min(a_{i-k+1},a_{i-k+2},...,a_{i})$ ，那么代价就变成了 $a_l+\min(a_l,g_{l+k})+\min(a_l,g_{l+k},g_{l+2\times k})+...$ 。

考虑如果代价是 $g_{l+k}+\min(g_{l+k},g_{l+2\times k})+...$ 怎么做。因为对于 $l$ 的询问只与下标和 $l$ 关于 $k$ 同余的$g$ 有关 ，所以我们可以把每个询问按照 $l\bmod k$ 分类，这样就相当于求一个后缀的前缀 $\min$ 的和，可以用单调栈维护。具体地，我们从右往左扫（从大到小加入下标和 $l$ 关于 $k$ 同余的 $g$），维护一个 $\min$ 的单调栈，假设栈中的第 $i$ 个元素是 $st_i$ 。对于栈中的每一个元素我们维护 $f_i$ 表示从 $st_i$ 到 $n$ 这个后缀的和，询问时差分即可。

回到原问题，其实我们只用在询问 $l$ 的时候往单调栈中插入 $a_l$ ，就可以了。因为下一插入的数是 $g_l$ ，而 $g_l\leq a_l$ ，所以 $a_l$ 自然会弹出去。预处理 $g$ 可以用ST表或单调队列。时间复杂度 $O(n\times \log(n))$ 或 $O(n)$ 。

## CF1403A

给出数轴上的 $n$ 个点，每个点的坐标为 $h_i$ 。有 $u$ 个时刻，每个时刻会有把两点之间的边 $(x,y)$ 连上或断开。保证任意时刻每个点的度数不超过 $d$ 。有 $q$ 组询问，每组询问 $(x,y,v)$ ，求在时刻 $v$ 时，找出两个点 $x'$ 和 $y'$ ，使得存在边 $(x,x')$ 和 $(y,y')$ ，且 $|h_{x'}-h_{y'}|$ 的值最小。询问强制在线。

$2\leq n\leq 10^5,1\leq d\leq 500,0\leq u\leq 2\times 10^5,1\leq q\leq 5\times 10^4$

因为每个点的度数不超过 $d$ ，所以可以考虑把所有与 $x$ 有边的点，所有与 $y$ 有边的点拿出来，然后再扫一遍判断 $|h_{x'}-h_{y'}|$ 的最小值。

显然我们不能直接存每个时刻的连边情况，于是我们可以使用线段树分治的思想。因为每个时刻是一个删边或加边的操作，所以单独看每条边，它存在的时间都是若干段区间，且这样的区间总数是 $O(u)$ 的。我们对时间建一棵线段树，线段树上的每个节点开一个 `set` 。对于每一个区间把它对应到线段树上的 $\log$ 个区间，并在每个区间的 `set` 中插入这条边。这样以后，要找 $v$ 时刻包含 $x,y$ 的边有哪些，只需要从线段树的根节点一直走到 $v$ 对应的叶子节点，并在这条路径上的每个 $set$ 中分别查找就好了。这道题的难点在于**卡常**。

时间复杂度 $O(u\times \log(u)^2+q\times d\times \log(d))$ 。

## CF1403B

有一棵 $n$ 个点的树，现在把这棵树的每条边都覆盖。具体方法为，把这棵树的**叶子节点**（度数为1）两两配对（每个点只能配对一次），每组配对都会把两点之间的路径覆盖，这样的代价是每组配对两点间的路径长度之和。现在有 $q$ 组询问，每次会在原树的基础上加入 $d_i$ 个点，具体地，对于每一个新加入的节点，会与原树上的某个节点连边。求最小的代价是多少，没有合法方案输出-1。每组询问相互独立。

$3\leq n\leq 10^5,1\leq q\leq 10^5,\sum{d_i}\leq 10^5$

首先有两个结论：

1. 当叶子个数为偶数时，一定存在合法方案。

   证明：类似于重心，我们一定可以找到一个点 $r$ ，将 $r$ 作为根后，满足 $r$ 的每个儿子的子树中叶子个数不超过总个数的一半。显然 $r$ 不是叶子节点。那么我们就将每个叶子节点两两匹配，使得匹配的两个节点不在 $r$ 的同一个儿子的子树中（因为每个儿子的子树中叶子个数都不超过一半，所以一定可行），容易证明这样以后，每条边都被覆盖了。

2. 每条边只会被覆盖一次或两次。

   证明：假设某一条边 $(u,v)$ 被覆盖了 $k$ 次，其中 $k>2$ 。设覆盖它的点对依次为 $(a_1,b_1),(a_2,b_2),...,(a_k,b_k)$ （$a_i$ 在 $u$ 的子树中，$b_i$ 在 $v$ 的子树中）。将 $a$ 和 $b$ 分别按照 `dfs序` 排序得到：$a_{p_1},a_{p_2},...,a_{p_k}$ ,$b_{q_1},b_{q_2},...,b_{q_k}$ 。那么我们可以如下构造，使得 $(u,v)$ 被覆盖的次数变成一次或两次：

   1. 若 $k$ 为奇数。设 $x=\lfloor \frac{k}{2}\rfloor$ ，则如下配对：
      $$
      (a_x,b_x)\\
      (a_{p_1},a_{p_{x+1}}),(a_{p_2},a_{p_{x+2}}),...,(a_{p_x-1},a_{p_k})\\
      (b_{p_1},b_{p_{x+1}}),(b_{p_2},b_{p_{x+2}}),...,(b_{p_x-1},b_{p_k})\\
      $$

   2. 若 $k$ 为偶数。设 $x=\lfloor \frac{k}{2}\rfloor,y=\lceil\frac{k}{2}\rceil$ ，则如下配对：
      $$
      (a_x,b_x),(a_y,b_y)\\
      (a_{p_1},a_{p_{x+1}}),(a_{p_2},a_{p_{x+2}}),...,(a_{p_y-1},a_{p_k})\\
      (b_{p_1},b_{p_{x+1}}),(b_{p_2},b_{p_{x+2}}),...,(b_{p_y-1},b_{p_k})\\
      $$

记 $fa(x)$ 为 $x$ 的父亲节点。根据结论 $2$ 我们容易得到进一步推论，任选一个非叶子节点 $rt$ 为根后，对于一个点 $u$ ，$(fa(u),u)$ 被覆盖的次数只与 $u$ 子树内的叶子个数的奇偶性有关，具体地，当叶子个数为奇数时，被覆盖一次，否则被覆盖两次。证明就是因为一个子树中总得有点和子树外的点匹配，根据结论 $2$ 我们知道这样的点的个数不超过 $2$ ，又因为子树内匹配的点的个数是 $2$ 的倍数，所以有以上结论。

所以我们只要求出有多少个点 $u$，其子树中的叶子个数是奇数就能快速计算答案。考虑加入了一些节点会发生什么。容易发现，加入一个节点，会使这个点到根的路径上的节点，子树中叶子个数的奇偶性发生变化。所以直接对所有加入的点建**虚树**并计算这个值即可。

时间复杂度 $O(n+\sum{d_i}\times \log(n))$ 。