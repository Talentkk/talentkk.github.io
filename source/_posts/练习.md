---
title: 练习
date: 2021/10/15 
description: 　
---
## CF814D

有 $n$ 个圆，且两两只存在包含、相切或相离的关系。将其分为两组，每组中只有奇数次被覆盖的被算入面积，求面积和最大。

$1\leq n\leq 10^3$

容易发现圆之间是树的关系，于是把每个圆看成一个点，$O(n^2)$ 建出一个森林。现在问题等价于给树上的每个节点染上黑白两种颜色，如果设第 $i$ 个点代表的圆的面积是 $s_i$ ，$i$ 到根的路径中**与 $i$ 颜色相同**的有 $c_i$ 个，则这样的答案是：

$\sum_{i}{s_i\times(-1)^{c_i}}$

现在要最大化答案。容易归纳证明，对于每颗树，最优策略是只把第二层的点染黑，其余点染白。

## CF1598G

有一个只含字符1到9的字符串 $S$ 和一个不含0的数字 $X$ ，设 $num(l,r)$ 表示 $S$ 的字串 $S[l,r]$ 代表的数字，求任意一个三元组 $(a,b,c)$ 满足 $num(a,b)+num(b+1,c)=X$ 。

$1\leq |S|\leq 5\times 10^5,2\leq X\leq 10^{200000}$ 

不妨设 $num(a,b)=A,num(b+1,c)=B$ 且 $A$ 为较大者。设 $X$ 的长度为 $len$ ，则 $A$ 的长度只有可能是 $len$ 或 $len-1$ 。当 $|A|=len$ 时，$|B|=len-\operatorname{lcp}(A,X)-1$ 或 $|B|=len-\operatorname{lcp(A,X)}$ 。当 $|A|=len-1$ 时， $|B|=len-1$ 。

使用 `Hash` 可以 $O(1)$ check。时间复杂度 $O(n)$ 。 

## BJ19351

有个人一开始在 $x$ 轴的位置，每单位时间他可以向左或向右走一步或者停在原地。有 $n$ 道闪电 $(t,x,r)$ ，表示 $t$ 时刻的时候这个人不能够站在 $(x-r,x+r)$ 这个区间内。有 $s$ 个询问 $(t,x)$，求出在 $t$ 时刻这个人能否走到位置 $x$ 。

$0\leq n,s\leq 200000,0\leq t\leq 10^9,-10^9\leq x\leq 10^9,1\leq r\leq 10^9$

如果设 $dp(i)$ 表示在时刻 $t$ ，$i$ 这个点能否到达（1能到达，0不能），则1将构成若干个连续段，且 $t$ 加 $1$ 时，每个连续段会向左右各扩张一个单位，而闪电就会把一个区间赋值成 $0$ 。我们可以用 `set` 维护每个连续段，并用 `priority_queue` 维护相邻两个连续段之间合并的时间。时间复杂度 $O(n\log(n))$  。

## CF867D

一个游戏有 $n$ 个卡关，按顺序在 $r$ 秒内完成算通关。对于第 $i$ 个卡关，有 $p_i$ 的概率用 $f_i$ 的时间完成，有 $1-p_i$ 的概率用 $s_i$ 的概率完成。每完成一个卡关后，可以决定继续下一个卡关或重新开始计时挑战。求期望完成时间。

$1\leq n\leq 50,1\leq s_i,t_i\leq 100,80\leq p_i\leq 90,\sum{f_i}\leq r\leq \sum{s_i}$

若设 $dp(i,j)$ 为到第 $i$ 关时（未完成 $i$ ），已花费 $j$ 秒的期望完成时间，则容易得到转移方程：
$$
dp(i,j)=\min(dp(1,0),p_i\times(dp(i+1,j+f_i)+f_i)+(1-p_i)\times(f(i+1,j+s_i)+s_i))
$$
这样的转移存在环，又因为有 $\min$ ，所以无法使用高斯消元。

考虑把 $dp(1,0)$ 的转移式展开，则等式右边一定是若干个关于 $dp(1,0)$ 的一次函数取 $\min$ 。作出左式和右式关于 $dp(1,0)$ 的函数图像（左式为一次函数，右式为上凸函数），因为只有一个交点，所以可以二分求出这个交点。具体地，通过二分左式的值，计算右式的取值，通过判断两个值的大小关系来决定往哪边移动。

## CF1606F

给出一棵 $n$ 个节点的有根树（根为 $1$），有 $q$ 组询问 $(u,i)$ 。在一组询问中，你可以删掉除了 $u$ 和 $1$ 以外的任意节点。当一个节点被删去后，它的儿子就变成了它父亲的儿子。假设进行了 $m$ 次操作后，$u$ 有 $c(u)$ 个儿子，问 $c(u)-m\times i$ 的最大值是多少。每组询问独立。

$1\leq n,q,i\leq 2\times 10^5$

考虑朴素的 $dp$ ，设 $dp(u,i)$ 表示以 $u$ 为根的这棵子树中，询问 $(u,i)$ 的答案。从儿子 $v$ 转移过来时，讨论 $v$ 是否要被删去，于是有转移方程：
$$
dp(u,i)=\sum_{v}{\max(dp(v,i)-i,1)}
$$
这样的 $dp$ 是 $O(n^2)$ 的，瓶颈在于状态数过多，以下先证明两个结论：

1. $dp(u,i)\leq dp(u,i+1)$ 

   假设 $dp(u,i+1)$ 的方案中删去了点集 $S$ ，那么在 $dp(u,i)$ 中也删去点集 $S$ 的价值一定小于等于 $dp(u,i+1)$ 。

2. 设 $d(u)$ 为节点 $u$ 的儿子数量，对于 $u\in [1,n]$ 只有 $O(n/(i+1))$ 个 $dp(u,i)\neq d(u)$ 。

   把转移方程 $\max$ 里面的1拿出来：
   $$
   dp(u,i)=d(u)+\sum_{v}{\max(dp(v,i)-i-1,0)}
   $$
   因为 $dp$ 是完全由 $d$ 决定的，即一个 $d$ 数组与一个 $dp$ 数组一一对应，所以我们考虑这样一种方式得到 $dp$ 数组的值。一开始 $d(x)=0,x\in[1,n]$ ，显然所有 $dp$ 也为0， 然后考虑把一个为 $0$ 的 $d(x)$ 变成它原来的值（$x$ 的儿子数量）会对 $dp$ 发生什么影响，发现最多会让 $x$ 的 $d(x)/(i+1)$ 个**原来 $dp(u,i) = d(u)$ 的祖先**变成 $dp(u,i)\neq d(u)$ 。所以把每个 $d$ 都变完后，对于一个固定的 $i$ ，最多会有 $\sum_{x}{d(x)/(i+1)}=(n-1)/(i+1)$ 个点满足 $dp(u,i)\neq d(u)$ 。

因为结论2，对于 $dp(u,i)\neq d(u)$ 的状态总个数是调和级数的。所以我们 $dp$ 的时候可以只存 $dp(u,i)\neq d(u)$ 的状态，又因为结论1，对于固定的 $u$ ，符合条件的状态一定是一个前缀，可以用 `vector` 维护。转移是 $O(1)$ 的，时间复杂度 $O(n\ln(n))$ 。

## CF1601D

有 $n$ 个人要爬一座初始高度为 $d$ 的山，每个人用二元组 $(p_i,a_i)$ 描述。对于一个人，若当前 $d\leq p$ ，他可以爬这座山，爬完后山的高度变为 $max(d,a)$ 。问最多有多少人可以爬山。

$1\leq n\leq 5\times 10^5,0\leq d\leq 10^9$

首先把 $p<d$ 的扔掉，然后将所有人分为两类，$p\geq a$ 和 $p<a$ 。考虑这样一种形成方案的方式，先从 $p<a$ 的人中选出一种合法方案，然后再将 $p\geq a$ 的人插入其中。这样显然是正确的。

那么对于 $p<a$ 的人的任意一种合法方案， $p\geq a$ 的人一定都可以被插入。

证明：假设 $p<a$ 的人求出的合法方案是 $x_1,x_2,...,x_k$ （即这些人依次爬山），那么一个 $p\geq a$ 的人 $y$，直接找到最大的 $i$ 满足 $a_{x_i}\leq p_y$ ，然后把 $y$ 插入到 $i$ 和 $i+1$ 之间就可以了。

所以现在问题就是如何对 $p<a$ 的人求最优的合法方案。容易发现，如果把一个人 $i$ 看作一个区间 $[p,a]$ ，这本质上就是在求最多的区间，使得区间两两不交。直接把所有区间按照右端点排序，然后贪心选择即可。

## CF1601E

给出 $n$ 个数 $a_i$ 和 $k$ ，有 $q$ 组询问，每组询问给出区间 $[l,r]$ ，求一个序列 $c_i$ 满足对于 $i\in[l,r]$ ， $\sum_{j=l}^{i}c_j\geq{\lfloor \frac{i-l}{k} \rfloor+1}$ ，序列 $c_i$ 的代价为 $\sum a_i\times c_i$ ，求代价最小。

$1\leq n,q\leq 300000,1\leq k\leq n$

容易发现这个代价本质上就是对一个后缀的若干段前缀 $\min$ 求和：
$$
\sum_{i=l+kx,x\in N}^{r}{\min_{j=l}^{i}{a_j}}
$$
如果我们设 $g_i=\min(a_{i-k+1},a_{i-k+2},...,a_{i})$ ，那么代价就变成了 $a_l+\min(a_l,g_{l+k})+\min(a_l,g_{l+k},g_{l+2\times k})+...$ 。

考虑如果代价是 $g_{l+k}+\min(g_{l+k},g_{l+2\times k})+...$ 怎么做。因为对于 $l$ 的询问只与下标和 $l$ 关于 $k$ 同余的$g$ 有关 ，所以我们可以把每个询问按照 $l\bmod k$ 分类，这样就相当于求一个后缀的前缀 $\min$ 的和，可以用单调栈维护。具体地，我们从右往左扫（从大到小加入下标和 $l$ 关于 $k$ 同余的 $g$），维护一个 $\min$ 的单调栈，假设栈中的第 $i$ 个元素是 $st_i$ 。对于栈中的每一个元素我们维护 $f_i$ 表示从 $st_i$ 到 $n$ 这个后缀的和，询问时差分即可。

回到原问题，其实我们只用在询问 $l$ 的时候往单调栈中插入 $a_l$ ，就可以了。因为下一插入的数是 $g_l$ ，而 $g_l\leq a_l$ ，所以 $a_l$ 自然会弹出去。预处理 $g$ 可以用ST表或单调队列。时间复杂度 $O(n\times \log(n))$ 或 $O(n)$ 。

## CF1403A

给出数轴上的 $n$ 个点，每个点的坐标为 $h_i$ 。有 $u$ 个时刻，每个时刻会有把两点之间的边 $(x,y)$ 连上或断开。保证任意时刻每个点的度数不超过 $d$ 。有 $q$ 组询问，每组询问 $(x,y,v)$ ，求在时刻 $v$ 时，找出两个点 $x'$ 和 $y'$ ，使得存在边 $(x,x')$ 和 $(y,y')$ ，且 $|h_{x'}-h_{y'}|$ 的值最小。询问强制在线。

$2\leq n\leq 10^5,1\leq d\leq 500,0\leq u\leq 2\times 10^5,1\leq q\leq 5\times 10^4$

因为每个点的度数不超过 $d$ ，所以可以考虑把所有与 $x$ 有边的点，所有与 $y$ 有边的点拿出来，然后再扫一遍判断 $|h_{x'}-h_{y'}|$ 的最小值。

显然我们不能直接存每个时刻的连边情况，于是我们可以使用线段树分治的思想。因为每个时刻是一个删边或加边的操作，所以单独看每条边，它存在的时间都是若干段区间，且这样的区间总数是 $O(u)$ 的。我们对时间建一棵线段树，线段树上的每个节点开一个 `set` 。对于每一个区间把它对应到线段树上的 $\log$ 个区间，并在每个区间的 `set` 中插入这条边。这样以后，要找 $v$ 时刻包含 $x,y$ 的边有哪些，只需要从线段树的根节点一直走到 $v$ 对应的叶子节点，并在这条路径上的每个 $set$ 中分别查找就好了。这道题的难点在于**卡常**。

时间复杂度 $O(u\times \log(u)^2+q\times d\times \log(d))$ 。

## CF1403B

有一棵 $n$ 个点的树，现在把这棵树的每条边都覆盖。具体方法为，把这棵树的**叶子节点**（度数为1）两两配对（每个点只能配对一次），每组配对都会把两点之间的路径覆盖，这样的代价是每组配对两点间的路径长度之和。现在有 $q$ 组询问，每次会在原树的基础上加入 $d_i$ 个点，具体地，对于每一个新加入的节点，会与原树上的某个节点连边。求最小的代价是多少，没有合法方案输出-1。每组询问相互独立。

$3\leq n\leq 10^5,1\leq q\leq 10^5,\sum{d_i}\leq 10^5$

首先有两个结论：

1. 当叶子个数为偶数时，一定存在合法方案。

   证明：类似于重心，我们一定可以找到一个点 $r$ ，将 $r$ 作为根后，满足 $r$ 的每个儿子的子树中叶子个数不超过总个数的一半。显然 $r$ 不是叶子节点。那么我们就将每个叶子节点两两匹配，使得匹配的两个节点不在 $r$ 的同一个儿子的子树中（因为每个儿子的子树中叶子个数都不超过一半，所以一定可行），容易证明这样以后，每条边都被覆盖了。

2. 每条边只会被覆盖一次或两次。

   证明：假设某一条边 $(u,v)$ 被覆盖了 $k$ 次，其中 $k>2$ 。设覆盖它的点对依次为 $(a_1,b_1),(a_2,b_2),...,(a_k,b_k)$ （$a_i$ 在 $u$ 的子树中，$b_i$ 在 $v$ 的子树中）。将 $a$ 和 $b$ 分别按照 `dfs序` 排序得到：$a_{p_1},a_{p_2},...,a_{p_k}$ ,$b_{q_1},b_{q_2},...,b_{q_k}$ 。那么我们可以如下构造，使得 $(u,v)$ 被覆盖的次数变成一次或两次：

   1. 若 $k$ 为奇数。设 $x=\lfloor \frac{k}{2}\rfloor$ ，则如下配对：
      $$
      (a_x,b_x)\\
      (a_{p_1},a_{p_{x+1}}),(a_{p_2},a_{p_{x+2}}),...,(a_{p_x-1},a_{p_k})\\
      (b_{p_1},b_{p_{x+1}}),(b_{p_2},b_{p_{x+2}}),...,(b_{p_x-1},b_{p_k})\\
      $$

   2. 若 $k$ 为偶数。设 $x=\lfloor \frac{k}{2}\rfloor,y=\lceil\frac{k}{2}\rceil$ ，则如下配对：
      $$
      (a_x,b_x),(a_y,b_y)\\
      (a_{p_1},a_{p_{x+1}}),(a_{p_2},a_{p_{x+2}}),...,(a_{p_y-1},a_{p_k})\\
      (b_{p_1},b_{p_{x+1}}),(b_{p_2},b_{p_{x+2}}),...,(b_{p_y-1},b_{p_k})\\
      $$

记 $fa(x)$ 为 $x$ 的父亲节点。根据结论 $2$ 我们容易得到进一步推论，任选一个非叶子节点 $rt$ 为根后，对于一个点 $u$ ，$(fa(u),u)$ 被覆盖的次数只与 $u$ 子树内的叶子个数的奇偶性有关，具体地，当叶子个数为奇数时，被覆盖一次，否则被覆盖两次。证明就是因为一个子树中总得有点和子树外的点匹配，根据结论 $2$ 我们知道这样的点的个数不超过 $2$ ，又因为子树内匹配的点的个数是 $2$ 的倍数，所以有以上结论。

所以我们只要求出有多少个点 $u$，其子树中的叶子个数是奇数就能快速计算答案。考虑加入了一些节点会发生什么。容易发现，加入一个节点，会使这个点到根的路径上的节点，子树中叶子个数的奇偶性发生变化。所以直接对所有加入的点建**虚树**并计算这个值即可。

时间复杂度 $O(n+\sum{d_i}\times \log(n))$ 。

## CF1535F

对于两个长度相同的字符串 $a,b$ ，你可以做以下操作，选择任意一个字符串的任意一个字串，并将它从小到大排序。

定义 $f(a,b)$ 为：进行上述操作能使 $a=b$ 的最小操作次数。若无论如何都不能使 $a=b$ ，则 $f(a,b)=1337$ 。现在给出 $n$ 个长度为 $m$ 的字符串 $s_1,s_2,...,s_n$ ，求 $\sum_{i=1}^{n}{\sum_{j=i+1}^{n}{f(s_i,s_j)}}$ 。

$n\times m\leq 10^5$

首先对于两个串，它们的每种字符出现次数相同一定有解，否则一定无解。所以我们根据每个串的字符出现的次数把它们分成若干个集合，这样不同集合之间的代价就确定了，现在考虑相同集合中的代价。

假设 $S,T$ 是同一个集合里面的两个串，那么 $f(S,T)$ 只有 $3$ 种取值：$0,1,2$ 。若 $f(S,T)=0$ ，显然 $S=T$ 。现在 $S\neq T$ ，考虑如何判断对于两个给定的串 $S,T$ 是否可以使 $f(S,T)=1$ 。如果我们可以找出一个区间 $[l,r]$ ，使得 $S[1,l-1]=T[1,l-1],S[r+1,n]=T[r+1,n]$ ，且其中一个串区间 $[l,r]$ **原本有序**，答案为 $1$ ，否则为 $2$ 。由于我们可以快速计算出 $0$ 的数量和 $0,1,2$ 的总数量，所以我们只要求出 $1$ 的数量就可以计算答案。

再次考虑上面判断两个串 $S,T$ 满足 $f(S,T)=1$ 的条件。容易证明如下的一种判断方式也是完全等价的：先找出**最大的** $l$ 使得 $S[1,l-1]=T[1,l-1]$ （$l$ 本质上就是 $lcp+1$），再找出**最大的** $r$ 满足其中一个串区间 $[l,r]$ 是有序的，最后再判断是否存在 $S[r+1,n]=T[r+1,n]$ 。

在计算答案前，我们先将所有串排序，这样的好处是若 $f(S,T)=1$ ，则其中**不使用操作**的串编号一定较小。我们枚举一个串 $s_i$ ，并希望计算有多少对 $f(s_i,s_j)=1$ ，其中 $j>i$ （也就是说 $i$ 不使用操作）。我们在从大到小枚举 $i$ 的同时，维护一个 $\min$ 的单调栈（大小是 $O(m)$ 的）。单调栈中的每个元素代表一个区间，由于每个区间中的串 $s_j$ 都满足 $lcp(s_i,s_j)$ 相同，所以我们对于单调栈中的每一个区间 $[L,R]$ 分别统计这个区间中有多少串使得 $f(s_i,s_j)=1$ 。由于 $lcp$ 是定值，所以上文中要找的 $l$ 也确定了，现在是要找最大的 $r$ 使得 $s_i[l,r]$ 原本有序，这个可以在一开始对于每个串的**有序极长**子区间进行预处理，所以 $r$ 也就确定了。现在的问题是要求有多少个标号在 $[L,R]$ 的串 $j$ 满足 $s_j[r+1,n]=s_i[r+1,n]$ ，我们直接将所有串的反串插入 `trie` 中，我们先定位 $s_i$ 的 $r+1$ 对应的节点，这样 `trie` 上所有经过这个节点且标号在 $[L,R]$ 之间的串就是符合条件的串，直接二分即可。

## CatOJ1098

给定一棵 $n$ 个点的二叉树，每个点有两个小于 $k$ 的权值。你可以进行两种操作：

1. 选定 $x,y$ ，使 $a_x=(a_x+y)\bmod k,b_x=(b_x+y)\bmod k$
2. 选定 $x,y$ ，对于每一个在 $x$ 子树中的点 $i$​ ，使 $a_i=(a_i+y)\bmod k,b_i=(b_i+y)\bmod k$ 。

求让所有点满足 $a_i\geq b_i$ 的最小次数。

$2\leq n\leq 2\times 10^5,2\leq k\leq 10^9$ 。

先考虑一个 $O(n^2)$ 的 $dp$ ，设 $dp(i,j)$ 表示外部对 $i$ 这个子树加的总和是 $j$ 时（就是从 $i$ 的父亲到根的2操作之和），使得 $i$ 这个子树合法需要的最小操作次数。设 $w(i,j)$ 表示给 $i$ 节点加上 $j$ 后，是否还需要操作才能使其变合法。那么转移为：
$$
dp(i,j)=dp(ls,j)+dp(rs,j)+w(i,j)\\
dp(i,j)=\min_{k}\{dp(i,k)\}+1
$$
其中第一种转移是先不考虑二操作，从子树转移过来（因为操作顺序不影响），然后第二种转移再考虑操作二。这样是 $n^2$ 的。

观察到其实第二个转移有很大的特殊性，这个转移使得对于同一个 $i$ ，$dp(i,j)$ 之间最多差 1（$w(i,j)$ 也满足）。所以对于一个 $i$ 我们只用维护**最小值**和最小值取到的位置，就可以表示这个状态。我们假设 $S(i)$ 为 $dp(i,j)$ 取到最小值的有那些 $j$ ，$v(i)$ 表示 $dp(i,j)$ 的最小值，$W(i)$ 表示有哪些 $w(i,x)$ 为0。考虑对于一个节点 $u$ 如何转移，因为转移式的三项都是满足上述性质的，所以 $v(u)$ 只有3种取值：

1. $S(ls),S(rs),W(u)$ 的并不为0，则 $v(u)=v(ls)+v(rs)$ 。
2. $S(ls),S(rs),W(u)$ 的交为0，则 $v(u)=v(ls)+v(rs)+2$ 。
3. 否则， $v(u)=v(ls)+v(rs)+1$ 。

转移中需要对集合进行的操作只用交和并就可以了。因为 $W(x)$ 最多是两段区间，而把两个集合一次交或并得到的集合的区间个数，是不超过原来两个集合区间个数的总数的。所以我们用 `set` 维护有哪些区间是属于这个集合，并在 $\min(S_1,S_2)$ 的时间内完成两个区间的交或并就可以了。复杂度类似启发式合并，$O(n\times\log(n)^2)$ 。

## CatOJ1099

给定一个长度为 $n$ 的序列 $a$ ，现在要将序列中的每个位置染成红、蓝两种颜色之一，使得：

+ 至少有一个位置被染成红色
+ 至少有一个位置被染成蓝色
+ 设 $R$ 为所有红色的数按位与的结果，$B$ 为所有蓝色的数按位与的结果，那么有 $R=B$。

求满足条件的染色方案。

$1\leq n\leq 50,0\leq a_i<2^{20}$

显然每个二进制位可以分开考虑，因为 $R=B$ ，所以 $R$ 和 $B$ 在每一位上都要相同。

考察某一个二进制位，如果这 $n$ 个数在这一位都是 $1$ ，则无论如何染色这一位都合法；如果这 $n$ 个数在这一位不全为 $1$ ，那么 $R$ 和 $B$ 在这一位上就都为 $0$ ，也就是说 $n$ 个数中这一位为 $0$ 的**不能染成一种颜色**。因为 $a_i<2^{20}$ ，所以有 $20$ 个这样的限制。

考虑容斥，我们枚举一个限制集合，并计算**强制这个集合中的限制都不成立**的方案数。而一条限制不成立就意味着，若干位置的颜色需要相同。也就是说，我们对于每一条集合中的限制，把这些颜色需要相同的位置用边连接起来，假设最终连通块数量是 $c$ ，那么对于这个集合的答案就是 $2^c-2$ 。用并查集来实现上述过程的复杂度是 $2^{20}\times 50\times 20$  ，难以通过。

但其实每次的并查集不用重新计算，我们从小到大枚举限制集合，并在过程中记录每个集合最终的并查集。这样对于枚举到的集合 $S$ ，我们就可以通过 $S-lowbit(S)$ 的并查集加入一个 $lowbit(S)$ 这个限制得到。复杂度是 $2^{20}\times 50$ 。

