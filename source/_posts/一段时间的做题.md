---
title: 做题记录
date: 2022/3/7
description: 　
---

# 2022.2

## [CF1307G Cow and Exercise](https://codeforces.com/contest/1307/problem/G)

设从 $u$ 到 $v$ 的路径长度为 $w_{u,v}$ （若没有则为 $inf$） ，对这条路径增加的长度为 $a_{u,v}$ 。设 $d_i$ 为一个长度为 $n$ 的向量，则原问题的答案等价于，对于满足以下条件的每一组 $(d,a)$ ，求 $\max(d_n-d_1)$ ：

+ $d_v-d_u-a_{u,v}\leq w_{u,v}$ （对于所有 $(u,v)$）
+ $\sum a_{u,v}= x$ 
+ $x_{u,v}\geq 0$

这是一个线性规划问题，对它进行对偶，设 $A_{u,v}$ 为一个 $n\times n$ 的矩阵，$B$ 为一个变量。则原问题等价于：

+ 求 $\min(\sum w_{u,v}A_{u,v}+Bx)$ 
+ $\sum_{i}{A_{i,u}}-\sum_i{A_{u,i}}=-1$ （$i=1$）
+ $\sum_i{A_{i,u}}-\sum_i{A_{u,i}}=0$ （$i\neq1,i\neq n$）
+ $\sum_i{A_{i,u}}-\sum_i{A_{u,i}}=1$ （$i=n$）
+ $A_{u,v}\leq B$ （对于所有$(u,v)$）
+ $A_{u,v}\geq 0$

令 $F_{u,v}=A_{u,v}/B$ ，问题转化为：

+ 求 $\min(B\times(\sum w_{u,v}F_{u,v}+x))$ 
+ $\sum_{i}{F_{i,u}}-\sum_i{F_{u,i}}=-\frac{1}{B}$ （$i=1$）
+ $\sum_i{F_{i,u}}-\sum_i{F_{u,i}}=0$ （$i\neq1,i\neq n$）
+ $\sum_i{F_{i,u}}-\sum_i{F_{u,i}}=\frac{1}{B}$ （$i=n$）
+ $F_{u,v}\leq 1$ （对于所有$(u,v)$）
+ $F_{u,v}\geq 0$ 

容易发现这个问题等价于：

+ 考虑一个费用流，$1$ 是源点，$n$ 是汇点。在 $(u,v)$ 之间建容量为 $1$ ，费用为 $w_{u,v}$ 的边。对于这个费用流的每一组可行流 $(flow,cost)$ ，求 $\min(\frac{cost+x}{flow})$ 。

显然我们对于一个固定的 $flow$ 只关心最小的 $cost$ ，记 $C(flow)$ 表示当流量为 $flow$ 时，最小的 $cost$ 是多少。（这个显然可以在 `SSP` 算法不断增广的过程中求得）。

然后一个重要的观察是，在 $x$ 固定时，$\frac{C(flow)+x}{flow}$ 这个式子关于 $flow$ 时凸的。（差分一下不难证明）

所以我们对于每个询问直接二分出最小值即可。

时间复杂度 $O(n^4+q\times \log(n^2))$ 。

## [CF1638F Two Posters](https://codeforces.com/contest/1638/problem/F)

我们记两个矩形在水平方向覆盖的区间分别是 $[l_1,r_1],[l_2,r_2]$ （这里钦定 $l_1\leq l_2$）。

接下来分几类情况讨论：

1. $r_1<l_2$ ，即两个区间不相交：

   对于这种情况，最优的操作方式一定是把某个前缀的板子尽可能往上移动，把某个后缀的板子尽可能往下移动。

   我们可以 $O(n)$ 地枚举这个“前缀”和“后缀”的分界点来计算答案。

2. $l_1\leq l_2\leq r_2\leq r_1$ ，即第一个区间包含第二个区间：

   对于这种情况，我们分别枚举 $l_2,r_2$ ，和第一个矩形的高度，并找到合法且最小的 $l_1$ 和合法且最大的 $r_1$ ，就可以计算答案。

   但这这个复杂度显然不可接受，两个重要的观察是：

   + 最优情况下，第一个矩形的高度必然等于 $h_i$ 中的一个。
   + 若 $h_{l_2-1}\geq \min(h_{l_2},h_{l_2+1},...,h_{r_2})$ 或 $h_{r_2+1}\geq \min(h_{l_2},h_{l_2+1},...,h_{r_2})$ ，则区间 $[l_2,r_2]$ 显然不优于 $[l_2-1,r_2]$ 或 $[l_2,r_2+1]$ 。那么我们有必要枚举的 $[l_2,r_2]$ 就只有 $O(n)$ 个。

   综上两点，这一部分的复杂度变成了 $O(n^2)$ 。

3. $1_1\leq l_2\leq r_1\leq r_2$ ，即两个区间相交但不包含：

   对于这种情况，我们枚举 $l_2,r_1$ 。

   与上一种情况类似，我们依然可以证明有必要枚举的 $l_2,r_1$ 只有 $O(n)$ 对。

   设第一个矩形的高度为 $A$ ，第二个矩形的高度为 $B$ ，$\min_{i=l_2}^{r_1}{h_i}=C$ ，接下来分两种情况讨论：

   + $A+B=C$ ，则 $A$ 与某个 $h_i$ 相同或 $B$ 与某个 $h_i$ 相同，显然这样的 $(A,B)$ 只有 $O(n)$ 对，枚举即可。
   + $A+B\neq C$ ，则 $A$ 与某个 $h_i$ 相同且 $B$ 与某个 $h_i$ 相同，这样的 $(A,B)$ 也只有 $O(n)$ 对，但需要先预处理一些信息。

   这一部分时间复杂度 $O(n^2)$ 。

## 高斯消元求行列式

对于一个 $n\times n$ 的矩阵 $A$ ，其行列式：
$$
\operatorname{det}(A)=\sum_{\sigma\in S_n}{\operatorname{sgn}(\sigma)\prod_{i=1}^{n}{a_{i,\sigma(i)}}}
$$
其中 $S_n$ 表示长度为 $n$ 的全排列集合，$\sigma$ 是一个全排列。记 $cnt$ 为 $\sigma$ 的逆序对个数，则 $\operatorname{sgn}(\delta)$ 的定义是：
$$
\operatorname{sgn(\sigma)}=(-1)^{cnt}
$$
 注意到行列式有若干重要性质：

+ 矩阵转置，行列式不变。
+ 矩阵行（列）交换，行列式取反。
+ 矩阵行（列）加减，行列式不变。
+ 矩阵行（列）同时乘 $k$ ，行列式乘 $k$ 。

根据以上四点，我们可以用类似高斯消元的方法来求行列式。

具体过程为，先把矩阵消成上三角矩阵，则对角线上所有数的乘积就是答案。

## LGV引理

内容参考 [OI-WIKI](https://oi-wiki.org/graph/lgv/) 。

作用是用来**有向无环图上**不相交路径的计数。

## [CatOJ P1210 道路重建](https://cwoi.com.cn/problem/P1210)

我们可以先考虑：分别给每条无向边对应的两条有向边 $(i,j),(j,i)$，同时减去它们最小值的代价，并将这个代价累加入答案。

一个重要结论是：

+ 对于任意一个满足题目性质的有向图，都可以由一个环和若干个耳组成（耳分解）。

这启发我们可以用状压 $dp$ 来解决问题。

设 $dp(s)$ 表示使得集合 $s$ 内的点两两可达的最小代价，枚举一条起点和终点分别在 $s$ 内的路径即可进行转移（这一步需要预处理）。时间复杂度 $O(3^n\times n^2)$ ，难以通过。

考虑转移时不一次性加入一条路径，而是每次加入路径上的一个点。设 $g(s,u,v)$ 表示当前已经**两两互通**的点集与**当前正在加入的路径上**的点集的并是 $s$ ，当前路径的走到了 $u$ ，终点在 $v$ 的最小代价。时间复杂度 $O(2^n\times n^3)$ 。

## [CatOJ P1211 单增矩阵](https://cwoi.com.cn/problem/P1211)

首先一个重要的观察是，问题等价于求有多少个大小为 $k-1$ 的路径组满足：

+ 起点在 $(n,0)$ ，终点在 $(0,m)$ 。
+ 路径始终沿着网格。
+ **路径两两不交叉** 。

如果问题没有 $a_{r,c}=v$ 这个限制，我们可以和把第 $i$ 条路径分别向右向下平移一个单位，问题转化为：

+ 第 $i$ 条路径起点在 $(n+i,i)$ ，终点在 $(i,m+i)$ 。
+ 路径始终沿着网格。
+ **路径两两不相交** 。

对于这个问题可用 `LGV` 引理解决。

考虑 $a_{r,c}=v$ 这个限制的存在等价于**恰好存在** $v-1$ 条路径在 $(r-1,c-1)$ 的上方，那么平移后，这个限制等价于：

+ 恰有 $v-1$ 条路径满足：第 $i$ 条路径在 $(r-1+i,c-1+i)$ 的上方。

但问题在于这个限制**对于平移后的每一条路径是不同的**，所以转化一下限制，容易发现上面的东西等价于：

+ 恰有 $v-1$ 条路径满足：第 $i$ 条路径在 $(r-1+v,c-1+v)$ 上方。且没有路径经过点 $(r+v,c+v)$ 。

对于 `LGV` 的矩阵 $M$ ，我们设 $M(i,j)=a_{i,j}x+b_{i,j}$ 。其中：

$a_{i,j}$ 表示从 $(n+i,i)$ 到 $(m+j,j)$ 的所有路径中，在 $(r-1+v,c-1+v)$ 上方，且没有路径经过点 $(r+v,c+v)$ 的路径数。

$b_{i,j}$ 表示从 $(n+i,i)$ 到 $(m+j,j)$ 的所有路径中，不在 $(r-1+v,c-1+v)$ 上方，且没有路径经过点 $(r+v,c+v)$ 的路径数。

那么根据 `LGV` 引理 ，$[x^{v-1}]\operatorname{det}(M)$ 就是答案。

另一个棘手的问题是如何对多项式求行列式（因为不太能消成上三角矩阵），其实注意到 $\operatorname{det}(M)$ 的次数只有 $O(k)$ ，直接插值即可。

时间复杂度 $O(n^4)$ 。

## [[ZJOI2017]字符串](https://www.luogu.com.cn/problem/P5211)

这个题目的区间加操作十分棘手，考虑用线段树来维护。

我们称对于一个串 $s$ ，$s[i...n]$ 这个后缀是好的，当且仅当可能存在一个字符串 $t$ ，满足 $st$ 这个字符串中从 $s_i$ 开始的后缀是最小的。

两个重要的观察是：

+ 对于字符串 $s$ 的两个好的后缀，短的后缀一定不超过长的一半。
+ 一个字符串 $s$ 的好的后缀是 $\log(n)$  级别的。

于是我们可以在线段树的每个节点上分别维护 $\log(n)$ 个好的后缀。

考虑如何合并，假设当前要合并区间 $[l,mid],[mid,r]$ ，其中 $mid-l+1\geq r-mid+1$ 。容易发现左半区间**最多贡献一个好的后缀**。所以我们可以直接拿出左半间中 $\log$ 个好的后缀在当前区间中对应的后缀，并找出最小的一个即可。虽然这个后缀可能不是好的，但不影响复杂度。

每次询问时，我们直接找出询问对应的 $\log$ 个区间，取出 $\log^2$ 个好的后缀暴力比较即可。

考虑这样的复杂度，比较两个字符串时我们可以用 `hash` + 二分解决，其中 `hash` 用分块维护，时间复杂度为 $n\times \log^2+m\times \sqrt n+m\times \log^3$ 。

## [CF1635F Closest Pair](https://codeforces.com/contest/1635/problem/F)

一个重要的观察：是对于一对 $(i,j)$ ，若有 $w_i\geq \min(w_{i+1},...,w_{j-1})$ 或 $w_j\geq \min(w_{i+1},...,w_{j-1})$ ，则这对数带来的贡献可以被忽略。

根据这个结论，我们有必要考虑的 $(i,j)$ 就只有 $O(n)$ 对。找出这些 $(i,j)$ 后，可以用 `BIT` + 扫描线询问答案。

## [ABC240H Sequence of Substrings](https://atcoder.jp/contests/abc240/tasks/abc240_h)

一个简单的 $dp$ 是设 $dp_{i,j}$ 表示考虑前 $j$ 个字符，选的最后一段是 $[i,j]$ ，最多能选多少段。考虑 $dp_{i,j}$ 应该从哪些状态转移来，显然有：$dp_{i,j}\leftarrow dp_{k,l}+1$ （ $l<i$ 且 $s[i,j]$ 的字典序大于 $s[k,l]$）。如果我们按照字典序从小到大遍历所有字串，并用 `BIT` 来支持转移，可以得到一个 $O(n^2\times \log(n))$ 的做法。

一个重要的观察是：

+ 记 $\operatorname{len}(t)$ 为字符串 $t$ 的长度，则若 $\operatorname{len}(s_i)+1<\operatorname{len}(s_{i+1})$ ，则一定不优。

 也就是说可能出现在最优方案中的字串长度是 $O(\sqrt n)$ 的，前面 $dp$ 的状态数就变成了 $O(n\sqrt n)$ ，加上 `BIT` 的复杂度，时间复杂度为 $O(n\times \log(n)\times \sqrt n)$ 。

## [AGC009D Uninity](https://atcoder.jp/contests/agc009/tasks/agc009_d)

很有意思的题。

首先容易想到用点分治的过程去做这道题，试试就知道这样不一定最优，但却能得到一个重要的结论：最优的答案一定不超过 $\log$ 。

由于原题是一个**递归**的过程，这不便于我们完成此题，考虑对题意进行转化。当我们把若干个等级为 $k-1$ 的子树合并到 $u$ 上时，可以给 $u$ 这个节点染上颜色 $k$ ，这样的操作会使得对于每一种方案，每个点都有一个唯一的颜色，观察这样的颜色有什么性质：

+ 对于任意 $u,v(u\neq v)$ ，满足 $col_u=col_v$ ，则在 $u$ 到 $v$ 的路径上必然存在一点 $x$ ，满足 $col_x>col_u$ 。

同时也可以发现，这样的转化是充分的，即：对于任意一种满足上述条件的染色方案，都对应原题中一种合法的方案。现在考虑如何对这个问题进行计算。

假设对与节点 $u$ ，它的儿子 $v_1,v_2,...,v_k$ 的子树内**所有节点的颜色都已经确定了**，则在 $u$ 处填的颜色应该满足哪些条件呢？

我们设 $c(x)$ 为一个颜色的集合，代表在 $x$ 的子树中，对任意 $col\in c(x)$ ，存在一个颜色为 $col$ 的节点 $y$ ，满足 $y$ 到 $x$ 的路径上不存在颜色比 $col$ 大的节点。回到刚刚的问题，对于每个儿子 $v_i$ 的子树，我们显然只关心 $c(v_i)$ 这个颜色集合内的颜色，则 $u$ 的颜色 $col_u$ 应满足：

+ 对于任意颜色 $col$ ，若存在 $col\in c(v_i)$ ，则应有 $col_u\neq col$ 。
+ 对于任意颜色 $col$ ，若存在 $col\in c(v_i),col\in c(v_j),i\neq j$ ，则应有 $col_u>col$ 。

事实上，我们从叶子到根**贪心**地进行这个过程，即每次都给 $u$ 填上能填的最小的颜色，就能通过此题。

考虑这样的正确性，我们记一个颜色集合的代价为：
$$
w(s)=\sum_{col\in s}{B^{col}}
$$
其中 $B$ 是一个非常大的整数。

则对于节点 $u$ 来说，$c(u)$ 应该满足的条件实际上是 $w(c(u))>\sum w(c(v_i))$ 。而最终我们的目的是最小化 $w(c(1))$ ，那么这个贪心的正确性就显而易见了。

考虑这样的复杂度，由于我们知道 $c(u)$ 的大小是不超过 $\log$ 的，所以时间复杂度是 $n\times \log(n)$ 。