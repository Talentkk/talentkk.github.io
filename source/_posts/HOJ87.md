---
title: HOJ87
date: 2021/12/25
description: 　
---

给一棵 $n$ 个点的树，边有边权。你要选出 $k$ 个互不相同的点 $c_0,c_1,..,c_{k-1}$，使得 $\sum_{i}{dis(c_i,c_{(i+1) \bmod k})}$ 最大。

$1\leq n,k\leq 8\times 10^5$

考虑一条边对答案可能的贡献（被计算了多少次）。对于一条边 $(u,v)$ ，假设 $u$ 一侧选了 $x$ 个点，则 $v$ 一侧选了 $k-x$ 个点，也就是说 $(u,v)$ 最多会被经过 $2\times \min(x,k-x)$ 次。

容易证明这个上界总是可以取到的。具体的构造方式为，取点 $p$ 满足：以 $p$ 为根时， $p$ 的每个儿子 $v$ 中被选点的数量不超过 $\frac{k}{2}$ （$p$ 一定存在），然后构造 $c$ 序列，使得任意 $c_i,c_{i+1}$ 不在 $p$ 的同一个儿子的子树即可。

也就是说，对于任意的 $k$ 个点 $c_1,c_2,...,c_k$ ，每条边 $(u,v)$ 都可以被经过 $2\times \min(x,k-x)$ 次 。于是记 $dp(u,x)$ 表示以 $u$ 为根的子树中，选了 $x$ 个点的最大代价。转移为：
$$
dp'(u,x+y)\leftarrow dp(u,x)+dp(v,y)+2\times \min(y,k-y)\times w
$$
其中 $w$ 为 $(u,v)$ 的边权，直接转移时间复杂度 $O(n^2)$ 。

注意到转移的代价只和 $y$ 有关，所以我们可以记 $g(u,x)=dp(u,x)+2\times \min(x,k-x)\times w$ ，转移就变成了：
$$
dp'(u,x+y)\leftarrow dp(u,x)+g(v,y)
$$
容易发现这实际上是 $\max,+$ 卷积，且对于固定的 $u$ ，$dp(u,x)$ 是凸的。可以用闵可夫斯基和优化。

具体地，假设 $a_i$ 和 $b_i$ 都是凸的，且它们进行 $\max,+$ 卷积后得到 $c_i$ ，则有：

+ 记 $a'_i$ 为 $a_i$ 的差分数组，$b'_i$ 是 $b_i$ 的差分数组，$c_i'$ 是 $c_i$ 的差分数组，则 $c'_i$ 是由 $a'_i$ 和 $b'_i$ 从小到大归并起来构成的。

于是我们对每个节点用 `splay` 维护 $dp(u,x)$ 和 $g(u,x)$ 的差分数组 。每次的转移相当于将 $v$ 的平衡树中的所有元素，插入到 $u$ 的平衡树中，得到 $dp(u,x)$ 的差分数组。再对 $u$ 所在的平衡树进行前 $\lfloor \frac{k}{2}\rfloor$ 个数加 $2w$ ，第 $\lceil \frac{k}{2} \rceil+1$ 到最后一个数减 $2w$ ，就得到 $g(u,x)$ 的差分数组。

如果合并两个平衡树时，把小的向大的合并，时间复杂度 $O(n\log(n)^2)$ ，会 TLE 。

注意到整个过程其实是把 $n$ 个大小为 $1$ 的平衡树合并，最终变成大小为 $n$ 的一个平衡树。有两个经典结论是：

+ 对于两个大小分别为 $n$ 和 $m$ 的 `splay` （$n\leq m$），把 $n$ 中的所有元素按照**中序遍历**插入 $m$ 中，时间复杂度 $O(n\times \log(\frac{m}{n}))$ 。
+ 按照上述方式，按任意顺序合并 $n$ 个大小为 $1$ 的 `splay` 复杂度是 $O(n\times \log(n))$ 。

