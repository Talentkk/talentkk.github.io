---
title: ABC233G
date: 2021/12/22
description: 　
---

给一个 $n$ 个点的图。对每一对 $(i,j)$ 满足 $i\neq j$ ，$i,j$ 间存在边权为 $(a_i+b_j)\bmod m$ 的边。求 $1$ 到 $n$ 的最短路。

$2\leq n\leq 2\times 10^5,2\leq m\leq 10^9,0\leq a_i,b_i<m$ 

注意到 $a_i,b_i<m$ ，则 $(a_i+b_j)\bmod m$ 的取值只有可能是 $a_i+b_j$ 或 $a_i+b_j-m$ 。如果我们固定 $i$ ，把所有 $b_j$ 排序后，可以发现取值为 $a_i+b_j$ 的是一段前缀，为 $a_i+b_j-m$ 的是一段后缀。于是引出以下三种做法。

注意下文中的点都已经按照 $b_i$ 排序。

### 方法一：

考虑 `dijkstra` 的过程，我们用一棵线段树来代替堆，并支持查询当前 $dis_u$ 最小的点，以及维护 $dis_u$ 这个序列。我们事先将所有点按照 $b_i$ 的大小排序。假设当选出 $dis$ 最小的点是 $i$ ，设 $k$ 是最大的一个满足 $a_i+b_k<m$ 的下标，那么 $dis_i$ 对其它点 $dis$ 的更新操作就是：
$$
dis_j\leftarrow \min(dis_j,a_i+b_j)(j\leq k)\\
dis_j\leftarrow \min(dis_j,a_i+b_j-m)(j>k)
$$
 这并不能直接用线段树维护，考虑维护 $d_i=dis_i-b_i$ ，则每次的更新操作变成：
$$
d_j\leftarrow \min(d_j,a_i)(j\leq k)\\
d_j\leftarrow \min(d_j,a_i-m)(j>k)
$$
并要支持查询 $d_i+b_i$ 的最小值，以及把某个 $b_i$ 变成 $inf$ （在一个点被更新后）。这可以通过在线段树上标记永久化方便实现，时间复杂度 $O(n\times \log(n))$ 。

### 方法二：

固定 $i$ 以后，对于不同 $j$ 的连边有很大相似性，考虑建图优化。

新的图中存在 $3\times n$ 个点，其中依次为原来的点 $x_i$ ，前缀点 $p_i$ ，后缀点 $s_i$ 。

记一条边 $(u,v,w)$ 表示，一条从 $u$ 到 $v$ ，边权为 $w$ 的边。

连边如下：

+ 对 $i\in[1,n]$ ，$(p_i,x_i,b_i),(s_i,x_i,b_i)$
+ 对 $i\in[1,n-1]$ ，$(p_{i+1},p_i,0)$
+ 对 $i\in[2,n]$ ，$(s_{i-1},s_i,0)$
+ 对 $i\in[1,n]$ ，设 $k$ 是最大的一个满足 $a_i+b_k<m$ 的下标，$(i,p_k,a_i),(i,s_{k+1},a_i-m)$ 

这样的正确性是显然的，但是由于图中存在负边，所以无法使用 `dijkstra` 求最短路。

对边权进行调整：

+ 对 $i\in[1,n]$ ，$(p_i,x_i,b_i),(s_i,x_i,b_i)$
+ 对 $i\in[1,n-1]$ ，$(p_{i+1},p_i,0)$
+ 对 $i\in[2,n]$ ，$(s_{i-1},s_i,b_i-b_{i-1})$
+ 对 $i\in[1,n]$ ，设 $k$ 是最大的一个满足 $a_i+b_k<m$ 的下标，$(i,p_k,a_i),(i,s_{k+1},a_i+b_{k+1}-m)$ 

这样就可以 `dijkstra` 求解问题。

### 方法三：

还是考虑建图优化。

考虑从余数进行下手。设 $A_i=m-a_i$ ，$(a_i+b_j)\bmod m=(b_j-A_i) \bmod m$ 

我们考虑建出一个大小为 $m$ 的环，其中的点分别为 $p_0,p_1,...,p_{m-1}$ ，从 $p_i$ 向 $p_{(i+1)\bmod m}$ 连边权为 $1$ 的边，则 $(b_j-A_i)\bmod m$ 正是环上 $A_i$ 到 $b_j$ 的距离。对于一个原图中的点 $i$ ，连边 $(i,A_i,0)$ 以及 $(b_i,i,0)$ 即可。但是注意到这样的点数是 $O(m+n)$ 的，无法通过。

容易发现环上的点有很多都是可以缩在一起的。具体地，只有在 $A_i$ 和 $b_i$ 中出现过的点是关键的点，其它的都可以忽略。这样的点数是 $O(n)$ 的，时间复杂度 $O(n\times \log (n))$ 。 