---
title: CF79D
date: 2021/12/4
description: 　
---

你有 $n$ 个灯泡，一开始都未点亮。

同时你有 $l$ 个长度，分别为 $a_1 \sim a_l$ 。

每次你可以选择一段连续的子序列，且长度为某个 $a_i$ ，并将这些灯泡的明灭状态取反。

求最少的操作次数，使得最后有且仅有 $k$ 个位置是亮的，这些位置已经给定，为 $x_1 \sim x_k$ 。

$1\leq n\leq 10^4,1\leq k\leq 10,1\leq l\leq 100$

区间的操作不好考虑，考虑差分。

即设 $b_i=a_i \oplus a_{i+1}$ ，则依次对区间 $[i,i+l-1]$ 的操作，相当于对 $b_{i-1},b_{i+l-1}$ 进行取反，也就是对两个距离为 $l$ 的数取反。观察到，每次操作后，$b$ 序列中 $1$ 的个数的奇偶性不会改变，所以如果最终序列有奇数个 $1$ ，无解。

考虑将最终的 $b$ 序列还原成初始的 $b$ 序列（全为 $0$ ），容易发现，最优的还原过程一定是依次把两个数抵消掉。设 $cost(i,j)$ 为把第 $i$ 个 $1$ 与第 $j$ 个 $1$ 抵消的最小操作次数。这相当于是求一个序列 $t$ 满足 $t_1=i,t_k=j,|t_i-t_{i+1}|=x_j$ ，直接从每个为 $1$ 的位置开始 `bfs` 就可以了。

对于后面的部分就是套路的状压 $dp$ ，设 $dp_S$ 还剩集合 $S$ 的位置为 $1$ 的最小操作次数，转移为：
$$
dp_{S}\leftarrow dp_{S|\{i\}|\{j\}}+cost(i,j)
$$
时间复杂度 $O(n\times m\times k+2^k\times k^2)$ 。