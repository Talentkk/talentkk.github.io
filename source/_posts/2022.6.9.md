---
title: 2022.6.9
date: 2022/6/9
description: 　
---

## CF843D

有一张 $n$ 个点 $m$ 条边的有向带权图，你需要回答如下的 $q$ 个问题：

1. `1 v` 询问以 $1$ 为起点到 $v$ 的最短路
2. `2 c l_1 l_2 ... l_c` 对于 $l_1, l_2, \ldots, l_c$ 的边的边权增加 $1$。

不存在输出 `-1`。

$1 \leq n, m \leq 10^5$，$1 \leq q \leq 2000$。

直接在每次询问后暴力跑 `dij` 的复杂度是 $nq\log n$ ，不能过。

考虑优化，注意到只要 `dij` 的过程中 $dis$ 的最大值是 $O(n)$ 的，那么我们就可以用 $O(n)$ 个桶来代替原先的堆，复杂度变为 $O(n+m)$ 。

于是我们考虑在每次修改后，处理出 $f_i$ 表示 $i$ 这个点与 $1$ 号点的距离在这次操作后增加了多少。现在考虑用 `dij` 的过程得到 $f_i$ ，那么一条边 $(u,v,w)$ 的边权应当是 $dis_u+w-dis_v$ ，又由于 $f_i\leq n-1$ 一定成立，所以我们可以用桶来优化 `dij` ，这样时间复杂度相较暴力就少了一个 $\log$ 。

## ARC102C

有 $n$ 个骰子，每个骰子有 $k$ 个面，上面有 $1$ 到 $k$。骰子都是一样的。

现在对于 $[2,2k]$ 中的每一个数 $x$，要求出任意投这个 $n$ 个骰子使得不存在任意两个骰子的点数和为 $x$ 的方案数。

$n,k\le 2000$

对于固定的 $x$ 和任意 $1\leq i\leq x-1$ ，显然 $i$ 和 $x-i$ 只能有一个出现（$2i=x$ 除外，此时 $i$ 的出现次数必须不超过 $1$）。这样的限制形如若干对数，而不同的对之间的数是没有任何限制的。于是我们考虑依次加入这些有限制的对，并计算方案数。

设 $dp(i,j)$ 表示考虑前 $i$ 对（不考虑 $2i=x$ 的情况），加入了 $j$ 个数的方案数，转移为：

+ 不加入这一对中的任何数：$dp_{i,j}\leftarrow dp_{i-1,j}$
+ 加入 $k$ 个数，由于可以是两个中的任意一种，所以：$dp_{i,j}\leftarrow 2dp_{i-1,j-k}$

再设 $g(i,j)$ 表示考虑 $i$ 个没有限制的数，加入了 $j$ 个数的方案数，转移类似，都可以用前缀和优化到 $O(n^2)$ 。

然后对于每一个 $x$ ，我们只需枚举有限制的数有多少个和是否存在 $2i=x$ 的数，即可计算答案。

## AGC002E

桌上有 $N$ 堆糖果,第 $i$ 堆糖果有 $A_i$ 个糖。两人在玩游戏，轮流进行，每次进行下列两个操作中的一个

1. 将当前最大的那堆糖果全部吃完

2. 将每堆糖果吃掉一个

吃完的人输,假设两人足够聪明，问谁能必胜。

$1<=n<=10^5,1<=a_i<=10^9$

考虑将所有 $a_i$ 从大到小排序，然后化成柱状图：

![](https://s2.ax1x.com/2019/10/13/uxC5ND.png)

可以发现执行操作一等价于删去最下面一行，执行操作二等价于删去最左边一列，于是问题相当于：一个棋子一开

始在图中的左下角 $(1,1)$ ，每人每步可以将棋子向上或向右移动一步，无路可走算输。

![](https://s2.ax1x.com/2019/10/13/uxite0.png)

画个图出来（图中指的是每个点必胜还是必败）可以发现：除去边界，对角线上的状态是相同的。那么要求 $(1,1)$ ，我们先可以找到最大的 $i$ 满足 $(i,i)$ 在图形内且不在边界上。现在问题是求 $(i,i)$ 的状态，而这个状态又与：从 $(i,i)$ 向上走到边界的距离与从 $(i,i)$ 向右走到边界的距离的奇偶性有关，故直接判断即可。时间复杂度 $O(n\times \log n)$ 。

## CF842E

一棵树初始只有一个编号为 1 的根结点。

$n$ 次操作，每次新增一个点作为 $p_i$ 的子结点，询问更新后有多少点可以作为树直径的端点。

$n\le3\times10^5$。

考虑对于一棵固定的树如何求答案。我们先从任何一个点出发，找到距离它最远的集合 $s1$ ，再从 $s1$ 中的任何一个点出发，找到距离它最远的**且不在** $s1$ 中的点集 $s2$ 。那么此时有两种情况：

1. $s1$ 与 $s2$ 中的任何一对点都是直径。
2. 设 $s=s_1\cup s_2$ ，则 $s$ 中的任何一对不相同的点都是直径。

以上信息告诉我们，任何一棵树的直径都可以用两个集合刻画，且可以作为直径端点的点的个数恰好是两个集合的大小和。

考虑在加入有一个点 $x$ 后如何快速更新集合。我们设原先集合的直径为 $d$ ，设 $x$ 与 $s1$ 中某个点的距离是 $d_1$ ，$x$ 与 $s_2$ 中的某个点的距离是 $d_2$ ，分几种情况讨论：

+ $\max(d_1,d_2)=d$ ，则此时 $x$ 会作为直径的端点，若 $d_1\geq d_2$ ，则将 $x$ 放入 $s_2$ ，否则放入 $s_1$ 。
+ $\max(d_1,d_2)>d$ ，则此时 $x$ 会作为直径的端点，$x$ 应该插入哪个集合与上一种情况类似，但是需要特别注意的是：
  1. 在插入 $x$ 前，这个集合需要先清空。
  2. 由于原先的集合可能是上文中的情况 $2$ （即一个点在 $s_1$ 也可以在 $s_2$），这种情况下，要将这个集合的点全部移向另一个集合。
+ $\max(d_1,d_2)<d$ ，忽略 $x$ 即可。

所有的插入删除操作都是均摊 $O(1)$ 的，瓶颈在于用 `lca` 求树上距离。