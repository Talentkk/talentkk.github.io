---
title: 模拟赛
date: 2021/10/16
description: 　
---

# C组模拟（20211019）

## Problem A

给定一排长度为 $2\times n$ 的格子，每个格子都是黑色或白色。可以进行 $n$ 次操作 $[l,r]$ ，表示翻转区间 $[l,r]$ 的格子的颜色。所有操作结束后，每个格子应恰好被选择一次。问有多少种方案使得最后所有格子都是白色。

$1\leq n\leq 10^5$

观察可得每个格子作为左端点还是右端点是固定的。具体来说，第一个格子是左端点。若 $color_i=color_{i+1}$ ，则 $i$ 和 $i+1$ 中一左一右；否则 $i$ 和 $i+1$ 都是左或右。因为最后的结果只和哪些点是左右端点有关，而和它们如何匹配无关，所以答案就是，每个右端点左边左端点个数的乘积与 $n!$ 的积。时间复杂度 $O(n)$ 。

## Problem B

给 $n$ 个点，有 $q$ 次操作：

1. 询问 $u$ 和 $v$ 是否联通，若联通，输出它们之间的距离。
2. 在 $u$ 和 $v$ 之间加权值为 $w$ 的边。

保证图随时是一棵树。

$1\leq n,q\leq 5\times 10^5,w\leq 1000$

先对所有操作二建出一棵森林，预处理树上 `lca` 。然后用并查集动态维护连通性，判断两点是否联通。时间复杂度 $O(n\log(n))$ 。

## Problem C

给 $n$ 个点 $m$ 条边的无向图，你需要将它划分为两个点集，使得每一个点集中的任意两点间都存在边。如果存在这样的划分方案，则输出 $m$ 条边中满足两个端点属于同一个点集的边数量的最小值。否则输出 $-1$ 。

$2\leq n\leq 2000 ,0\leq m\leq \frac{n*(n-1)}{2}$

显然如果存在，就是要使两个点集的差尽量小。因为任意两点间都有边，不好考虑，所以考虑原图的补图。原来的问题转化成了求一个二分图，使得左右部差最小。我们可以先判断原图是不是一个二分图，然后对于每个连通块（二分图），求出两边分别有多少个点，然后背包即可。时间复杂度 $O(n^2)$ 。

## Problem D

在 $n*n$ 的网格图上有 $m$ 个格子是黑色的，若存在 $(x,y),(y,z)$ 是黑色的，就可以将 $(z,x)$ 涂成黑色。问最多存在多少个黑色格子。

$1\leq n,m\leq 10^5$

可以把问题转化到图论中，对于一个黑色点，从它的行号到列号连一条有向边。如果我们把从 $u$ 到 $v$ 的路径（这里可以走反向边）权值定义为：正向边权值为 $1$ ，反向边权值为 $-1$ 。则最后 $(x,y)$ 是黑色的充要条件是存在一条从 $x$ 到 $y$ 的路径，满足：

1. 路径权值模 $3$ 余 $1$ 。
2. 路径长度为 $1$ 或路径中存在两个相邻的正/反向边。

考虑如何统计这样的路径数量。先考虑没有限制2，我们把一个点分裂成三个 $x_0,x_1,x_2$，分别代表余数为 $0,1,2$ ，对于原图中 $x$ 连向 $y$ 的有向边，我们在新图中建出 $(x_0,y_1),(x_1,y_2),(x_2,y_0)$ 的无向边。这样后对于每个点 $u$ ，以它为路径起点的合法路径数就是，$u_0$ 所在联通块中 $i_1$ 的数量。再考虑第二个限制，可以发现，路径中不存在两个相邻相同的边等价于 $u_0$ 所在连通块中没有 $i_2$ 。所以对于一个点 $u$ ，若它的联通块中有 $i_2$ ，贡献为它连通块中 $i_1$ 的个数，否则为它原始图中的出度（代表长度为 $1$ 的路径）。可用并查集实现，时间复杂度 $O(n \alpha(n))$ 。

<iframe src="/pdf/20211019C.pdf" width="100%" height="500px"></iframe>

# C组模拟（20211016）

## Problem A

给定一个长度为 $n$ 的序列 $a$ 和一个参数 $k$ 。问对于将序列 $a$ 重复 $k$ 次的序列 $b$ ，它的逆序对是多少。

$1\leq n,a_i\leq 5000,1\leq k\leq 10^6$

把 $b$ 中的每一个 $a$ 序列看成一个段。然后把逆序对直接分成段内的和段外的计算。时间复杂度 $O(n^2)$ 。

## Problem B

给出平面上的 $n$ 个点，现在可以给点之间两两连边，边权是两点欧几里得距离的平方。对于一种方案，代价是连通块个数乘 $v$ 加边权和。求最小代价。

$1\leq n\leq5000 ,0\leq v\leq 10^5,0\leq x,y\leq 30000$

显然有环不优。所以可以先求一棵最小生成树，然后把边权大于 $v$ 的断掉即可。求最小生成树时用 `Prim` 可以 $O(n^2)$ 。

## Problem C

一个人在数轴上，每秒可以向左移动一个单位，向右移动一个单位，或原地不动。初始位置为 $0$ ，他要到达位置 $e$ ，途中有 $n$ 个景点依次位于 $x_1,x_2...x_n$ （升序）。一个景点到达即可参观，但参观完一次后要等 $t$ 秒才能参观下一次。如果这个人想在途中参观每个景点至少两次，最少需要多少时间。

$1\leq n\leq 100000,1\leq e,t\leq 10^9,0<x_1<x_2<...<x_n<e$

观察可得最优方案一定是每次都参观完一个连续段，再参观下一个连续段。即如果返回，一定会把当前点前面没有参观完的（两次）都参观完。所以容易得到 $O(n^2)$ 的 $dp$ ，设 $dp_i$ 为参观完 $1$ 到 $i$ 的最少时间。转移为：
$$
dp_i=\min(dp_j+a_i-a_{j-1}+\max(2\times (a_i-a_j),t))
$$
 对于后面的 $\max$ 讨论下取值，如果当前 $dp$ 到 $i$ ，那么一定是一个前缀的 $j$ 取到 $\max$ 左边，其余的取到 $\max$ 右边。所以可以两个分别维护（用单调队列）。时间复杂度 $O(n)$ 。

## Problem D

给定三个正整数 $x,y,z$ ，定义一个序列 $a$ 是好的，当且仅当这个序列存在三个相邻的连续字段，它们的和分别是 $x,y,z$ 。问所有长度为 $n$ ，值域在 $[1,10]$ 之间的序列有多少是好的。

$1\leq n\leq 50,1\leq a,b,c\leq 6$

考虑计算有多少序列是不好的。注意到这三个连续段的和不超过 $18$ ，所以可以设 $dp_{i,j}$ 表示，考虑序列的前 $i$ 个元素，前 $i$ 个元素构成的序列是不好的，且后缀和的集合为 $j$ 的方案数。因为后缀和是单增的，所以可以直接状压是否存在后缀和为 $x$ 的后缀。转移时直接枚举下一个字符并检查序列是否会变好。

<iframe src="/pdf/20211016C.pdf" width="100%" height="500px"></iframe>
