---
title: CF702F
date: 2021/12/8
description: 　
---

有 $n$ 种 T 恤，每种有价格 $c_i$ 和品质 $q_i$ 。

有 $m$ 个人要买 T 恤，第 $i$ 个人有 $v_i$ 元，每人每次都会买一件能买得起的 $q_i$ 最大的 T 恤。一个人只能买一种 T 恤一件，所有人之间都是独立的。

问最后每个人买了多少件 T 恤？如果有多个 $q_i$ 最大的 T 恤，会从价格低的开始买。

$1\leq n,m\leq 2\times 10^5,1\leq c_i,q_i,v_i\leq 10^9$

将所有 T 恤按照 $q_i$ 为第一关键字从大到小，$c_i$ 为第二关键字从小到大排序。考虑用一个数据结构维护当前 $m$ 个人分别剩余的钱，和每个人买的 T 恤数量，并依次遍历每件 T 恤，让所有当前能买的买，并维护上述值，这样的正确性是显然的。考虑用平衡树维护（`fhq_reap`），每次的操作是对当前权值超过 $c_i$ 的减 $c_i$。这是一个经典问题，先把当前的平衡树分裂成三棵 $[0,c_i-1],[c_i,2\times c_i-1],[2\times c_i,10^9]$ ，称作 $a,b,c$ 。注意到对 $b,c$ 都需要对它们的权值整体减 $c_i$ ，计数器整体加 $1$ 。但是这样后并不能直接把三棵树依次按序合并，因为注意到平衡树合并时的条件时第一颗的最大值不超过第二棵的最小值。但是我们发现，直接把 $a,c$ 合并起来是对的（因为现在 $c$ 的最小值依然不小于 $a$ 的最大值），然后我们把 $b$ 中的每一个元素依次插入 $a,c$ 合并起来的平衡树即可。

考虑这样的复杂度，如果不考虑暴力插入 $b$ 的部分，都是 $O(n\times \log(m))$ 的。我们发现对于 $b$ 的一个元素 $x$ （满足 $c_i\leq x\leq 2\times c_i-1$），减去 $c_i$ 后 $x$ 至少减半。也就是说一个值最多被插入 $\log(v_i)$ 次，一次插入是 $\log(m)$ 的，所以总时间复杂度 $O(n\times \log(m)\times \log(v_i))$ 。

