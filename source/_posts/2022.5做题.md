---
title: 2022.5做题
date: 2022/5/15
description: 　
---

## CF620F Xors on Segments
直接枚举一个区间并更新答案，复杂度是 $O(n^2\times m)$ 。
我们可以只枚举区间的左端点，并对右端点求前缀 $max$ 来更新答案，复杂度变为 $O(n\times m+n^2)$ 。
## CF1476G Minimum Difference
有以下观察：
1. 记 $c_i$ 为区间中 $cnt_j=i$ 的个数，则问题等价于求对于所有 $(l,r)$ ，满足 $\sum_{i=l}^{r}{c_i} \geq k$ ，$r-l$ 最小是多少。
2. $c_i\neq 0$ 的位置只有 $\sqrt n$ 个。

我们直接用带修莫队处理出 $c$ 数组，用链表维护不为 $0$ 的位置，并在询问时使用 `two pointers` 求答案即可。
时间复杂度 $O(n^{\frac{5}{3}})$ 。
## CF232E Quick Tortoise
考虑对行进行 `cdq分治` 。假设当前处理的区间是 $[l,r]$ ，令 $mid=(l+r)/2$ ，则我们要快速处理所有 $x_1\leq mid\leq x_2$ 的询问。
容易发现，从 $(x_1,y_1)$ 到 $(x_2,y_2)$ 的路径一定会通过 $mid$ 这一行，所以我们可以把路径拆开，记 $f(i,j,k)$ 表示是否可以从 $(i,j)$ 到达 $(mid,k)$ ，$g(i,j,k)$ 表示是否可以从 $(mid,k)$ 到 $(i,j)$ ，则当且仅当存在一个 $i$ 满足 $f(x_1,y_1,i)=1\cap g(x_2,y_2,i)=1$ 是有解。
以上的 $f,g$ 可以通过 `bitset` 处理，时间复杂度 $O(\frac{n^2\times m\times \log n}{w}+q\times \log n)$ 。
## CF710F String Set Queries
由于保证了字符串的总长度，所以字符集中所涉及到的字符串长度种类是 $O(\sqrt n)$ 级别的，每次询问时我们只需枚举模板串对应长度的所有字串，并判断是否在集合中出现即可。时间复杂度 $O(n\times \sqrt n)$ 。
## URAL1560 Elementary Symmetric Functions
考虑用线段树维护。我们对线段树的每个区间分别维护 $S(0)$ 到 $S(k)$ ，如果知道左右区间的 $S(i)$ ，那么显然可以在 $O(k^2)$ 的时间得到当前区间的 $S(i)$ 。时间复杂度 $O(n\times k^2\times \log n)$ 。
## URAL2119 Tree Hull
考虑对于一个固定的点集如何计算答案，把点集内的所有点按照 `dfs序` 排序，假设为 $i_1,i_2,...,i_k$ ，则 $2\times ans=\sum_{x=1}^{k}{dis(i_x,i_{x+1})}$ ，其中 $i_{k+1}=i_1$ ，$dis(x,y)$ 表示 $(x,y)$ 两点间的距离。那么我们可以用一个 `set` 来维护点集中点的 `dfs序` ，插入和删除操作时，只需对答案加上变化量即可。时间复杂度 $O(n\times \log n)$ 。
## CF946G Almost Increasing Array
记 $dp(i,0/1)$ 表示考虑前 $i$ 个位置，是否删去过一个数，且 $i$ 这个位置没有改变的最小修改次数，用树状数组优化即可，时间复杂度 $O(n\times \log n)$ 。使用 $a_i \to a_i-i$ 的技巧可以把问题转化为单调不降，更加方便。
## URAL1717 Eligibility Rules
枚举矩形的下边界 $r$ ，考虑矩形的上边界 $l\to l-1$ 的过程，相当于单点修改，求全局最大字段和，用线段树维护即可。时间复杂度 $O(n^2\times \log n)$ 。
## CF351E Jeff and Permutation
思维题。
考虑把逆序对 $(i,j)$ 的贡献放到绝对值较大的数上计算。对于 $a_i$ ，如果 $a_i=|a_i|$ ，则代价为 $i$ 之后比 $a_i$ 小的数，如果 $a_i=-|a_i|$ ，则代价为 $i$ 之前比 $a_i$ 小的数，直接统计出两者并取 $min$ 即可。时间复杂度 $O(n\times \log n)$ 。
## P8292 [省选联考 2022] 卡牌
考虑容斥，枚举一个集合 $S$ ，设选出来数的乘积不含任何一个 $S$ 中的质因子的方案数是 $f(S)$ ，则最终答案为：$\sum_{S}{(-1)^{|S|}\times f(S)}$ 。
把这个过程放到 $dp$ 上，我们从小到大考虑每个质数，记 $f(i,S)$ 表示考虑前 $i$ 个质数，枚举的集合为 $S$ 的带系数权值。转移为：$f(i,S)\to f(i+1,S),f(i,S)\to f(i+1,i\or {p_i})\times 2^{-dp(S,p_i)}$ 。其中 $dp(S,i)$ 表示对于所有不是 $S$ 中的元素倍数的卡片中，有多少是 $i$ 的倍数。
注意到当 $p_i>\sqrt n$ 时，我们并不关心 $S$ 中的那些也大于 $\sqrt n$ 的质数，因为它们的乘积已经超过了 $n$ ，对 $dp(S,p_i)$ 没有额外的影响。所以 $S$ 的大小就只有 $2^{14}$ ，可以通过。
## CatOJ 树的染色
对于每一个子树，我们记一个二元组 $(x_0,x_1)$ 表示这棵子树中两种颜色分别的权值和，根据题目有 $x_0=v_i$ 或 $x_1=v_i$ 。容易归纳证明，每次贪心地使其中不等于 $v_i$ 的那个尽可能小是最优的。对于一个节点 $u$ ，在得到其所有儿子的二元组后，可以使用背包求出 $u$ 节点的二元组，时间复杂度 $O(n^2)$ 。
## CatOJ 树形图求和
### 做法1：
设一条边的边权为 $w_ix+1$ ，矩阵树定理后，答案为行列式的一次项系数。由于这里并不关心大于一次的系数，所以可以做到 $O(n^3)$ 求行列式。
### 做法2：
枚举一条边 $i$ ，并计算不包含这条边的方案数 $c_i$ ，假设整个图的生成树数量是 $C$ ，则答案为 $\sum_{i}(w_i\times(C-c_i))$。
考虑如何快速计算 $c_i$ ，显然不能直接用矩阵树定理暴力计算。容易发现不包含 $i$ 的拉普拉斯矩阵与这个图的拉普拉斯矩阵只在 $(u_i,v_i)$ 与 $(u_i,u_i)$ 上有区别。记 $M$ 为原图拉普拉斯矩阵去掉第 $n$ 行和第 $n$ 列后的矩阵， $f(i,j)$ 为 $M(i,j)$ 的代数余子式，则有 $\operatorname{det}(M)=\sum_{i=1}^{n-1}{M(k,i)\times f(k,i)}$ ，其中 $k$ 可以为 $[1,n-1]$ 的任意整数。这里我们取 $k=u_i$ ，由于只改变了 $M(u_i,u_i)$ 和 $M(u_i,v_i)$ ，所以 $u_i$ 这一行的 $f$ 都不会改变，可以 $O(n)$ 计算。求 $f$ 可以使用**伴随矩阵**，时间复杂度 $O(n^3)$ 。
## CatOJ 波波老师
先建出 $SAM$ ，并找到那些 $|endpos|=1$ 的节点。然后问题转化为了若干次区间取 $\max$ ，排序后并查集即可。时间复杂度 $O(n\times \log n)$ 。 